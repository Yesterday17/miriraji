<template>
  <div>
    <MonacoEditor
      class="ml-editor"
      ref="editor"
      v-model="text"
      :theme="theme"
      @editorWillMount="willMount"
      @editorDidMount="didMount"
      @change="textChange"
      language="ml-language"
    />
    <DownloadDialog ref="download" :content="ass"></DownloadDialog>
  </div>
</template>

<script>
import MonacoEditor from "vue-monaco";
import DownloadDialog from "../components/DownloadDialog";

export default {
  components: {
    MonacoEditor,
    DownloadDialog
  },

  data() {
    return {
      text: "",
      theme: "ml",
      colorMap: {
        staff: "594d5e",
        pyon: "ea5b76",
        mocho: "ed90ba",
        kraz: "6495cf"
      },
      nameMap: {
        "[Pp]": "pyon",
        "[Kk]": "kraz",
        "[Mm]": "mocho",
        "[Ss]taff": "staff"
      },
      monaco: undefined,
      semicolons: undefined,
      semicolons_old: []
    };
  },
  methods: {
    willMount(monaco) {
      this.monaco = monaco;
      monaco.languages.register({ id: "ml-language" });
      monaco.languages.setMonarchTokensProvider("ml-language", {
        tokenizer: {
          root: [
            [/^[Pp]\s*[:：;；]\s*.+$/, "ml-pyon"],
            [/^[Kk]\s*[:：;；]\s*.+$/, "ml-kraz"],
            [/^[Mm]\s*[:：;；]\s*.+$/, "ml-mocho"],
            [/^[Ss]taff\s*[:：;；]\s*.+$/, "ml-staff"],
            [/^[(（]\*?[^)）]+[)）]$/, "ml-tip"]
          ]
        }
      });
      monaco.languages.registerHoverProvider("ml-language", {
        provideHover: (model, position) => {
          const range = monaco.Range.fromPositions(position, {
            column: position.column + 1,
            lineNumber: position.lineNumber
          });
          const word = model.getValueInRange(range);
          if (word.match(/[;；]/)) {
            return {
              range,
              contents: [{ value: "分号？" }]
            };
          }
        }
      });

      monaco.editor.defineTheme("ml", {
        base: "vs",
        inherit: true,
        rules: [
          ...Object.entries(this.colorMap).map(([key, value]) => {
            return { token: `ml-${key}`, foreground: value };
          }),
          { token: "ml-tip", foreground: "B6B3B2" }
        ]
      });
      monaco.editor.defineTheme("ml-dark", {
        base: "vs-dark",
        inherit: true,
        rules: [
          ...Object.entries(this.colorMap).map(([key, value]) => {
            return { token: `ml-${key}`, foreground: value };
          }),
          { token: "ml-tip", foreground: "B6B3B2" }
        ]
      });
    },
    didMount(editor) {
      editor.addAction({
        id: "ml-correct-semicolon",
        label: "快速清理分号(semicolon)",
        contextMenuGroupId: "navigation",
        contextMenuOrder: 1.5,
        run: () => {
          editor.executeEdits("source-ml", this.semicolons);
          return null;
        }
      });

      editor.addAction({
        id: "ml-generate-ass",
        label: "生成字幕文件(ass)",
        contextMenuGroupId: "navigation",
        contextMenuOrder: 1.5,
        run: () => {
          this.$refs.download.showDialog();
          return null;
        }
      });
    },
    textChange(t) {
      this.text = t;
      this.semicolons = this.$refs.editor
        .getEditor()
        .getModel()
        .findMatches("[;；]", false, true, false, false, false)
        .map(f => {
          return {
            text: ":",
            range: f.range,
            options: { inlineClassName: "squiggly-warning" }
          };
        });

      this.semicolons_old = this.$refs.editor
        .getEditor()
        .deltaDecorations(this.semicolons_old, this.semicolons);
    },
    reverseColor(color) {
      if (typeof color !== "string") {
        throw "color must be a string";
      } else if (!color.match(/^#?[0-9a-fA-F]{6}$/)) {
        throw "invalid color format";
      } else if (color.length === 7) {
        color = color.substr(1);
      }
      return [5, 6, 3, 4, 1, 2]
        .map(i => color[i - 1])
        .join("")
        .toUpperCase();
    },
    style(name, color, position = 2) {
      return `Style: ${name},方正准圆_GBK,35,&H00${this.reverseColor(
        color
      )},&H00FF0000,&H00FFFFFF,&H00000000,0,0,0,0,100,100,0,0,1,2,2,${position},10,10,10,1`;
    },
    line(text) {
      let style = "标注";
      let content = text;
      for (const regex in this.nameMap) {
        const match = text.match(new RegExp(`^${regex}\\s*[:：;；]\\s*(.+)$`));
        if (match) {
          style = this.nameMap[regex];
          content = match[1];
        }
      }
      return `Dialogue: 0,0:00:00.00,0:00:00.00,${style},,0,0,0,,${content}`;
    }
  },
  computed: {
    ass() {
      return `[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: None

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
${this.style("标注", "#B6B3B2", 7)}
${Object.entries(this.colorMap)
  .map(([key, value]) => this.style(key, value))
  .join("\n")}

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
${this.text
  .split("\n")
  .map(l => this.line(l))
  .join("\n")}
`;
    }
  }
};
</script>

<style lang="scss">
.ml-editor {
  overflow: hidden;
  width: 100vw;
  height: 90vh;
}

.semicolon-warn {
  text-decoration: underline red;
}
</style>
